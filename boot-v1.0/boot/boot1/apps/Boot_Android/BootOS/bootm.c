/*
 * (C) Copyright 2007-2011
 * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
 * Tom Cubie <tangliang@allwinnertech.com>
 *
 * Boot an image which is generated by android mkbootimg tool
 *
 * (C) Copyright 2000-2003
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */

/*
 * Misc boot support
 */
#include  "include.h"
#include  "boot_img.h"
#include  "setup.h"

#define   SUNXI_FLASH_ENV_SIZE    (128 * 1024)

static struct tag *params;
static unsigned char boot_hdr[512];

int do_boota(__u32 *start, __u32 kernal_address, __u32 para_addr)
{
	__u32  addr = kernal_address;
	__u32  kaddr, raddr;
	struct fastboot_boot_img_hdr *fb_hdr = (struct fastboot_boot_img_hdr *)addr;
	image_header_t *hdr =(image_header_t *)(addr + CFG_FASTBOOT_MKBOOTIMAGE_PAGE_SIZE);
	/* save the image header somewhere */

	memcpy(boot_hdr, (void*) addr, sizeof(*hdr));
	if (memcmp(fb_hdr->magic, FASTBOOT_BOOT_MAGIC, 8))
	{
		__inf("boota: bad boot image magic, maybe not a boot.img?\n");

		return -1;
	}
	//while((*(volatile unsigned int *)0x40000000) != 0x1234);

	kaddr = addr + fb_hdr->page_size;
	//raddr = kaddr + ALIGN(fb_hdr->kernel_size, fb_hdr->page_size);
	raddr = kaddr + ALIGN(fb_hdr->kernel_size, fb_hdr->page_size);

	memcpy((void*) fb_hdr->kernel_addr, (const void *)kaddr, fb_hdr->kernel_size);
	memcpy((void*) fb_hdr->ramdisk_addr, (const void *)raddr, fb_hdr->ramdisk_size);

	//while((*(volatile unsigned int *)0x40000000) != 0x1234);
	//__inf("ramdisk_size=%d\n", fb_hdr->ramdisk_size);
	linux_set_tags(fb_hdr, para_addr);

	*start = fb_hdr->kernel_addr;

	return 0;
}


static void setup_start_tag (__u32 para_addr)
{
	params = (struct tag *)para_addr;

	params->hdr.tag = ATAG_CORE;
	params->hdr.size = tag_size (tag_core);

	params->u.core.flags = 0;
	params->u.core.pagesize = 0;
	params->u.core.rootdev = 0;

	params = tag_next (params);
}


static void setup_end_tag (void)
{
	params->hdr.tag = ATAG_NONE;
	params->hdr.size = 0;
}


static void setup_commandline_tag (char *commandline)
{
	char *p;

	if (!commandline)
		return;

	/* eat leading white space */
	for (p = commandline; *p == ' '; p++);

	/* skip non-existent command lines so the kernel will still
	 * use its default command line.
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;

	strcpy (params->u.cmdline.cmdline, p);

	params = tag_next (params);
}


static void setup_initrd_tag (__u32 initrd_start, __u32 initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;

	params = tag_next (params);
}


int linux_set_tags(struct fastboot_boot_img_hdr *hdr, __u32 para_addr)
{
	__u32 initrd_start, initrd_end;
	char  *commandline = " console=ttyS0,115200 root=/dev/system init=/init loglevel=8";

	initrd_start = hdr->ramdisk_addr;
	initrd_end = initrd_start + hdr->ramdisk_size;

	setup_start_tag (para_addr);

	if(strlen((const char *)hdr->cmdline))
	{
		//__inf("%s %d\n", __FILE__, __LINE__);
		setup_commandline_tag ((char *)hdr->cmdline);
	}
	else
	{
		//__inf("%s %d\n", __FILE__, __LINE__);
		setup_commandline_tag (commandline);
	}

	if (hdr->ramdisk_size)
	{
		setup_initrd_tag (initrd_start, initrd_end);
	}

	setup_end_tag ();

	return 0;
}

